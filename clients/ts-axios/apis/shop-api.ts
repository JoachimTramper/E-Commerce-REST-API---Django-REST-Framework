/* tslint:disable */
/* eslint-disable */
/**
 * ECOMMERCE-API
 * REST API for managing products, orders, order items, user accounts and authentication 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: joachimtramper@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { Cart } from '../models';
// @ts-ignore
import type { OrderCreate } from '../models';
// @ts-ignore
import type { OrderDetail } from '../models';
// @ts-ignore
import type { OrderItemCreateUpdate } from '../models';
// @ts-ignore
import type { OrderItemDetail } from '../models';
// @ts-ignore
import type { PaginatedOrderCreateList } from '../models';
// @ts-ignore
import type { PaginatedOrderDetailList } from '../models';
// @ts-ignore
import type { PaginatedOrderItemDetailList } from '../models';
// @ts-ignore
import type { PaginatedOrderItemListList } from '../models';
// @ts-ignore
import type { PaginatedProductList } from '../models';
// @ts-ignore
import type { PatchedOrderCreate } from '../models';
// @ts-ignore
import type { PatchedOrderItemCreateUpdate } from '../models';
// @ts-ignore
import type { PatchedProduct } from '../models';
// @ts-ignore
import type { Product } from '../models';
/**
 * ShopApi - axios parameter creator
 * @export
 */
export const ShopApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemCreate: async (orderItemCreateUpdate: OrderItemCreateUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderItemCreateUpdate' is not null or undefined
            assertParamExists('cartItemCreate', 'orderItemCreateUpdate', orderItemCreateUpdate)
            const localVarPath = `/shop/cart/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderItemCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsList: async (ordering?: string, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/cart/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cartItemsRetrieve', 'id', id)
            const localVarPath = `/shop/cart/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCartItemsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopCartItemsDestroy', 'id', id)
            const localVarPath = `/shop/cart/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {PatchedOrderItemCreateUpdate} [patchedOrderItemCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCartItemsPartialUpdate: async (id: number, patchedOrderItemCreateUpdate?: PatchedOrderItemCreateUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopCartItemsPartialUpdate', 'id', id)
            const localVarPath = `/shop/cart/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOrderItemCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCartItemsUpdate: async (id: number, orderItemCreateUpdate: OrderItemCreateUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopCartItemsUpdate', 'id', id)
            // verify required parameter 'orderItemCreateUpdate' is not null or undefined
            assertParamExists('shopCartItemsUpdate', 'orderItemCreateUpdate', orderItemCreateUpdate)
            const localVarPath = `/shop/cart/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderItemCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current user\'s pending cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCartList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/cart/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsCreate: async (orderItemCreateUpdate: OrderItemCreateUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderItemCreateUpdate' is not null or undefined
            assertParamExists('shopOrderItemsCreate', 'orderItemCreateUpdate', orderItemCreateUpdate)
            const localVarPath = `/shop/order-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderItemCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopOrderItemsDestroy', 'id', id)
            const localVarPath = `/shop/order-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {string} [order] 
         * @param {ShopOrderItemsListOrderStatusEnum} [orderStatus] * &#x60;Pending&#x60; - Pending * &#x60;Confirmed&#x60; - Confirmed * &#x60;Shipped&#x60; - Shipped * &#x60;Delivered&#x60; - Delivered * &#x60;Cancelled&#x60; - Cancelled
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [product] 
         * @param {number} [quantityMax] 
         * @param {number} [quantityMin] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsList: async (order?: string, orderStatus?: ShopOrderItemsListOrderStatusEnum, ordering?: string, page?: number, pageSize?: number, product?: number, quantityMax?: number, quantityMin?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/order-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order__status'] = orderStatus;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (product !== undefined) {
                localVarQueryParameter['product'] = product;
            }

            if (quantityMax !== undefined) {
                localVarQueryParameter['quantity_max'] = quantityMax;
            }

            if (quantityMin !== undefined) {
                localVarQueryParameter['quantity_min'] = quantityMin;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {PatchedOrderItemCreateUpdate} [patchedOrderItemCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsPartialUpdate: async (id: number, patchedOrderItemCreateUpdate?: PatchedOrderItemCreateUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopOrderItemsPartialUpdate', 'id', id)
            const localVarPath = `/shop/order-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOrderItemCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopOrderItemsRetrieve', 'id', id)
            const localVarPath = `/shop/order-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsUpdate: async (id: number, orderItemCreateUpdate: OrderItemCreateUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopOrderItemsUpdate', 'id', id)
            // verify required parameter 'orderItemCreateUpdate' is not null or undefined
            assertParamExists('shopOrderItemsUpdate', 'orderItemCreateUpdate', orderItemCreateUpdate)
            const localVarPath = `/shop/order-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderItemCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersCheckoutCreate: async (orderId: string, orderCreate: OrderCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('shopOrdersCheckoutCreate', 'orderId', orderId)
            // verify required parameter 'orderCreate' is not null or undefined
            assertParamExists('shopOrdersCheckoutCreate', 'orderCreate', orderCreate)
            const localVarPath = `/shop/orders/{order_id}/checkout/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersCreate: async (orderCreate: OrderCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCreate' is not null or undefined
            assertParamExists('shopOrdersCreate', 'orderCreate', orderCreate)
            const localVarPath = `/shop/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersDestroy: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('shopOrdersDestroy', 'orderId', orderId)
            const localVarPath = `/shop/orders/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {string} [status] 
         * @param {number} [totalMax] 
         * @param {number} [totalMin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersList: async (createdAfter?: string, createdBefore?: string, ordering?: string, page?: number, pageSize?: number, search?: string, status?: string, totalMax?: number, totalMin?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (totalMax !== undefined) {
                localVarQueryParameter['total_max'] = totalMax;
            }

            if (totalMin !== undefined) {
                localVarQueryParameter['total_min'] = totalMin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {PatchedOrderCreate} [patchedOrderCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersPartialUpdate: async (orderId: string, patchedOrderCreate?: PatchedOrderCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('shopOrdersPartialUpdate', 'orderId', orderId)
            const localVarPath = `/shop/orders/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOrderCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersRetrieve: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('shopOrdersRetrieve', 'orderId', orderId)
            const localVarPath = `/shop/orders/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersUpdate: async (orderId: string, orderCreate: OrderCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('shopOrdersUpdate', 'orderId', orderId)
            // verify required parameter 'orderCreate' is not null or undefined
            assertParamExists('shopOrdersUpdate', 'orderCreate', orderCreate)
            const localVarPath = `/shop/orders/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsCreate: async (product: Product, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('shopProductsCreate', 'product', product)
            const localVarPath = `/shop/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductsDestroy', 'id', id)
            const localVarPath = `/shop/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [inStock] 
         * @param {string} [name] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [priceMax] 
         * @param {number} [priceMin] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsList: async (inStock?: boolean, name?: string, ordering?: string, page?: number, pageSize?: number, priceMax?: number, priceMin?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (inStock !== undefined) {
                localVarQueryParameter['in_stock'] = inStock;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (priceMax !== undefined) {
                localVarQueryParameter['price_max'] = priceMax;
            }

            if (priceMin !== undefined) {
                localVarQueryParameter['price_min'] = priceMin;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProduct} [patchedProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsPartialUpdate: async (id: number, patchedProduct?: PatchedProduct, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductsPartialUpdate', 'id', id)
            const localVarPath = `/shop/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductsRetrieve', 'id', id)
            const localVarPath = `/shop/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsUpdate: async (id: number, product: Product, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductsUpdate', 'id', id)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('shopProductsUpdate', 'product', product)
            const localVarPath = `/shop/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopApi - functional programming interface
 * @export
 */
export const ShopApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartItemCreate(orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartItemCreate(orderItemCreateUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.cartItemCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartItemsList(ordering?: string, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderItemListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartItemsList(ordering, page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.cartItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartItemsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartItemsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.cartItemsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopCartItemsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopCartItemsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopCartItemsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {PatchedOrderItemCreateUpdate} [patchedOrderItemCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopCartItemsPartialUpdate(id: number, patchedOrderItemCreateUpdate?: PatchedOrderItemCreateUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopCartItemsPartialUpdate(id, patchedOrderItemCreateUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopCartItemsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopCartItemsUpdate(id: number, orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopCartItemsUpdate(id, orderItemCreateUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopCartItemsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current user\'s pending cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopCartList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopCartList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopCartList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderItemsCreate(orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderItemsCreate(orderItemCreateUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrderItemsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderItemsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderItemsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrderItemsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {string} [order] 
         * @param {ShopOrderItemsListOrderStatusEnum} [orderStatus] * &#x60;Pending&#x60; - Pending * &#x60;Confirmed&#x60; - Confirmed * &#x60;Shipped&#x60; - Shipped * &#x60;Delivered&#x60; - Delivered * &#x60;Cancelled&#x60; - Cancelled
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [product] 
         * @param {number} [quantityMax] 
         * @param {number} [quantityMin] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderItemsList(order?: string, orderStatus?: ShopOrderItemsListOrderStatusEnum, ordering?: string, page?: number, pageSize?: number, product?: number, quantityMax?: number, quantityMin?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderItemDetailList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderItemsList(order, orderStatus, ordering, page, pageSize, product, quantityMax, quantityMin, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrderItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {PatchedOrderItemCreateUpdate} [patchedOrderItemCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderItemsPartialUpdate(id: number, patchedOrderItemCreateUpdate?: PatchedOrderItemCreateUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderItemsPartialUpdate(id, patchedOrderItemCreateUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrderItemsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderItemsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderItemsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrderItemsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderItemsUpdate(id: number, orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderItemsUpdate(id, orderItemCreateUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrderItemsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersCheckoutCreate(orderId: string, orderCreate: OrderCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersCheckoutCreate(orderId, orderCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrdersCheckoutCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersCreate(orderCreate: OrderCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersCreate(orderCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrdersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersDestroy(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersDestroy(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrdersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {string} [status] 
         * @param {number} [totalMax] 
         * @param {number} [totalMin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersList(createdAfter?: string, createdBefore?: string, ordering?: string, page?: number, pageSize?: number, search?: string, status?: string, totalMax?: number, totalMin?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderDetailList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersList(createdAfter, createdBefore, ordering, page, pageSize, search, status, totalMax, totalMin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrdersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {PatchedOrderCreate} [patchedOrderCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersPartialUpdate(orderId: string, patchedOrderCreate?: PatchedOrderCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersPartialUpdate(orderId, patchedOrderCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrdersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersRetrieve(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersRetrieve(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrdersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersUpdate(orderId: string, orderCreate: OrderCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersUpdate(orderId, orderCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopOrdersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsCreate(product: Product, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsCreate(product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopProductsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopProductsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [inStock] 
         * @param {string} [name] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [priceMax] 
         * @param {number} [priceMin] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsList(inStock?: boolean, name?: string, ordering?: string, page?: number, pageSize?: number, priceMax?: number, priceMin?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsList(inStock, name, ordering, page, pageSize, priceMax, priceMin, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopProductsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProduct} [patchedProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsPartialUpdate(id: number, patchedProduct?: PatchedProduct, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsPartialUpdate(id, patchedProduct, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopProductsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopProductsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsUpdate(id: number, product: Product, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsUpdate(id, product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.shopProductsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShopApi - factory interface
 * @export
 */
export const ShopApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopApiFp(configuration)
    return {
        /**
         * 
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemCreate(orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Cart> {
            return localVarFp.cartItemCreate(orderItemCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsList(ordering?: string, page?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedOrderItemListList> {
            return localVarFp.cartItemsList(ordering, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemDetail> {
            return localVarFp.cartItemsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCartItemsDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.shopCartItemsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {PatchedOrderItemCreateUpdate} [patchedOrderItemCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCartItemsPartialUpdate(id: number, patchedOrderItemCreateUpdate?: PatchedOrderItemCreateUpdate, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemCreateUpdate> {
            return localVarFp.shopCartItemsPartialUpdate(id, patchedOrderItemCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this order item.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCartItemsUpdate(id: number, orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemCreateUpdate> {
            return localVarFp.shopCartItemsUpdate(id, orderItemCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current user\'s pending cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCartList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Cart>> {
            return localVarFp.shopCartList(options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsCreate(orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemDetail> {
            return localVarFp.shopOrderItemsCreate(orderItemCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemDetail> {
            return localVarFp.shopOrderItemsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {string} [order] 
         * @param {ShopOrderItemsListOrderStatusEnum} [orderStatus] * &#x60;Pending&#x60; - Pending * &#x60;Confirmed&#x60; - Confirmed * &#x60;Shipped&#x60; - Shipped * &#x60;Delivered&#x60; - Delivered * &#x60;Cancelled&#x60; - Cancelled
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [product] 
         * @param {number} [quantityMax] 
         * @param {number} [quantityMin] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsList(order?: string, orderStatus?: ShopOrderItemsListOrderStatusEnum, ordering?: string, page?: number, pageSize?: number, product?: number, quantityMax?: number, quantityMin?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedOrderItemDetailList> {
            return localVarFp.shopOrderItemsList(order, orderStatus, ordering, page, pageSize, product, quantityMax, quantityMin, search, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {PatchedOrderItemCreateUpdate} [patchedOrderItemCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsPartialUpdate(id: number, patchedOrderItemCreateUpdate?: PatchedOrderItemCreateUpdate, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemDetail> {
            return localVarFp.shopOrderItemsPartialUpdate(id, patchedOrderItemCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemDetail> {
            return localVarFp.shopOrderItemsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
         * @param {number} id A unique integer value identifying this order item.
         * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderItemsUpdate(id: number, orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemDetail> {
            return localVarFp.shopOrderItemsUpdate(id, orderItemCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersCheckoutCreate(orderId: string, orderCreate: OrderCreate, options?: RawAxiosRequestConfig): AxiosPromise<OrderDetail> {
            return localVarFp.shopOrdersCheckoutCreate(orderId, orderCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersCreate(orderCreate: OrderCreate, options?: RawAxiosRequestConfig): AxiosPromise<OrderDetail> {
            return localVarFp.shopOrdersCreate(orderCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersDestroy(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderDetail> {
            return localVarFp.shopOrdersDestroy(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {string} [status] 
         * @param {number} [totalMax] 
         * @param {number} [totalMin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersList(createdAfter?: string, createdBefore?: string, ordering?: string, page?: number, pageSize?: number, search?: string, status?: string, totalMax?: number, totalMin?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedOrderDetailList> {
            return localVarFp.shopOrdersList(createdAfter, createdBefore, ordering, page, pageSize, search, status, totalMax, totalMin, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {PatchedOrderCreate} [patchedOrderCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersPartialUpdate(orderId: string, patchedOrderCreate?: PatchedOrderCreate, options?: RawAxiosRequestConfig): AxiosPromise<OrderDetail> {
            return localVarFp.shopOrdersPartialUpdate(orderId, patchedOrderCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersRetrieve(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderDetail> {
            return localVarFp.shopOrdersRetrieve(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
         * @param {string} orderId A UUID string identifying this order.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersUpdate(orderId: string, orderCreate: OrderCreate, options?: RawAxiosRequestConfig): AxiosPromise<OrderDetail> {
            return localVarFp.shopOrdersUpdate(orderId, orderCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsCreate(product: Product, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.shopProductsCreate(product, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.shopProductsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [inStock] 
         * @param {string} [name] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [priceMax] 
         * @param {number} [priceMin] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsList(inStock?: boolean, name?: string, ordering?: string, page?: number, pageSize?: number, priceMax?: number, priceMin?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProductList> {
            return localVarFp.shopProductsList(inStock, name, ordering, page, pageSize, priceMax, priceMin, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProduct} [patchedProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsPartialUpdate(id: number, patchedProduct?: PatchedProduct, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.shopProductsPartialUpdate(id, patchedProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.shopProductsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this product.
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsUpdate(id: number, product: Product, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.shopProductsUpdate(id, product, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopApi - object-oriented interface
 * @export
 * @class ShopApi
 * @extends {BaseAPI}
 */
export class ShopApi extends BaseAPI {
    /**
     * 
     * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public cartItemCreate(orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).cartItemCreate(orderItemCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public cartItemsList(ordering?: string, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).cartItemsList(ordering, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this order item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public cartItemsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).cartItemsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this order item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopCartItemsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopCartItemsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this order item.
     * @param {PatchedOrderItemCreateUpdate} [patchedOrderItemCreateUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopCartItemsPartialUpdate(id: number, patchedOrderItemCreateUpdate?: PatchedOrderItemCreateUpdate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopCartItemsPartialUpdate(id, patchedOrderItemCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this order item.
     * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopCartItemsUpdate(id: number, orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopCartItemsUpdate(id, orderItemCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current user\'s pending cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopCartList(options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopCartList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
     * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrderItemsCreate(orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrderItemsCreate(orderItemCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
     * @param {number} id A unique integer value identifying this order item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrderItemsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrderItemsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
     * @param {string} [order] 
     * @param {ShopOrderItemsListOrderStatusEnum} [orderStatus] * &#x60;Pending&#x60; - Pending * &#x60;Confirmed&#x60; - Confirmed * &#x60;Shipped&#x60; - Shipped * &#x60;Delivered&#x60; - Delivered * &#x60;Cancelled&#x60; - Cancelled
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [product] 
     * @param {number} [quantityMax] 
     * @param {number} [quantityMin] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrderItemsList(order?: string, orderStatus?: ShopOrderItemsListOrderStatusEnum, ordering?: string, page?: number, pageSize?: number, product?: number, quantityMax?: number, quantityMin?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrderItemsList(order, orderStatus, ordering, page, pageSize, product, quantityMax, quantityMin, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
     * @param {number} id A unique integer value identifying this order item.
     * @param {PatchedOrderItemCreateUpdate} [patchedOrderItemCreateUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrderItemsPartialUpdate(id: number, patchedOrderItemCreateUpdate?: PatchedOrderItemCreateUpdate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrderItemsPartialUpdate(id, patchedOrderItemCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
     * @param {number} id A unique integer value identifying this order item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrderItemsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrderItemsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all order items. - Non-staff users:     • list/retrieve: only items from their own orders.     • create: only if they have at least one PENDING order.     • update/partial_update: only on items whose order status == PENDING.     • delete: only on items whose order status == PENDING.
     * @param {number} id A unique integer value identifying this order item.
     * @param {OrderItemCreateUpdate} orderItemCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrderItemsUpdate(id: number, orderItemCreateUpdate: OrderItemCreateUpdate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrderItemsUpdate(id, orderItemCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
     * @param {string} orderId A UUID string identifying this order.
     * @param {OrderCreate} orderCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersCheckoutCreate(orderId: string, orderCreate: OrderCreate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersCheckoutCreate(orderId, orderCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
     * @param {OrderCreate} orderCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersCreate(orderCreate: OrderCreate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersCreate(orderCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
     * @param {string} orderId A UUID string identifying this order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersDestroy(orderId: string, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersDestroy(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
     * @param {string} [createdAfter] 
     * @param {string} [createdBefore] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {string} [status] 
     * @param {number} [totalMax] 
     * @param {number} [totalMin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersList(createdAfter?: string, createdBefore?: string, ordering?: string, page?: number, pageSize?: number, search?: string, status?: string, totalMax?: number, totalMin?: number, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersList(createdAfter, createdBefore, ordering, page, pageSize, search, status, totalMax, totalMin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
     * @param {string} orderId A UUID string identifying this order.
     * @param {PatchedOrderCreate} [patchedOrderCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersPartialUpdate(orderId: string, patchedOrderCreate?: PatchedOrderCreate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersPartialUpdate(orderId, patchedOrderCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
     * @param {string} orderId A UUID string identifying this order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersRetrieve(orderId: string, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersRetrieve(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Admin users: full CRUD on all orders. - Non-staff users:     • list/retrieve: only their own orders.     • create: may create orders for themselves.     • update/partial_update: only on their own orders when status == PENDING.     • delete: only on their own orders when status == PENDING.
     * @param {string} orderId A UUID string identifying this order.
     * @param {OrderCreate} orderCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersUpdate(orderId: string, orderCreate: OrderCreate, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersUpdate(orderId, orderCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsCreate(product: Product, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsCreate(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [inStock] 
     * @param {string} [name] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [priceMax] 
     * @param {number} [priceMin] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsList(inStock?: boolean, name?: string, ordering?: string, page?: number, pageSize?: number, priceMax?: number, priceMin?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsList(inStock, name, ordering, page, pageSize, priceMax, priceMin, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this product.
     * @param {PatchedProduct} [patchedProduct] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsPartialUpdate(id: number, patchedProduct?: PatchedProduct, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsPartialUpdate(id, patchedProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this product.
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsUpdate(id: number, product: Product, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsUpdate(id, product, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ShopOrderItemsListOrderStatusEnum = {
    Cancelled: 'Cancelled',
    Confirmed: 'Confirmed',
    Delivered: 'Delivered',
    Pending: 'Pending',
    Shipped: 'Shipped'
} as const;
export type ShopOrderItemsListOrderStatusEnum = typeof ShopOrderItemsListOrderStatusEnum[keyof typeof ShopOrderItemsListOrderStatusEnum];
